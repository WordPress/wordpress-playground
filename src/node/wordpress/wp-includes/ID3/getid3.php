<?php
 if (!defined('GETID3_OS_ISWINDOWS')) { define('GETID3_OS_ISWINDOWS', (stripos(PHP_OS, 'WIN') === 0)); } if (!defined('GETID3_INCLUDEPATH')) { define('GETID3_INCLUDEPATH', dirname(__FILE__).DIRECTORY_SEPARATOR); } if (!defined('ENT_SUBSTITUTE')) { define('ENT_SUBSTITUTE', (defined('ENT_IGNORE') ? ENT_IGNORE : 8)); } $temp_dir = ini_get('upload_tmp_dir'); if ($temp_dir && (!is_dir($temp_dir) || !is_readable($temp_dir))) { $temp_dir = ''; } if (!$temp_dir && function_exists('sys_get_temp_dir')) { $temp_dir = sys_get_temp_dir(); } $temp_dir = @realpath($temp_dir); $open_basedir = ini_get('open_basedir'); if ($open_basedir) { $temp_dir = str_replace(array('/', '\\'), DIRECTORY_SEPARATOR, $temp_dir); $open_basedir = str_replace(array('/', '\\'), DIRECTORY_SEPARATOR, $open_basedir); if (substr($temp_dir, -1, 1) != DIRECTORY_SEPARATOR) { $temp_dir .= DIRECTORY_SEPARATOR; } $found_valid_tempdir = false; $open_basedirs = explode(PATH_SEPARATOR, $open_basedir); foreach ($open_basedirs as $basedir) { if (substr($basedir, -1, 1) != DIRECTORY_SEPARATOR) { $basedir .= DIRECTORY_SEPARATOR; } if (strpos($temp_dir, $basedir) === 0) { $found_valid_tempdir = true; break; } } if (!$found_valid_tempdir) { $temp_dir = ''; } unset($open_basedirs, $found_valid_tempdir, $basedir); } if (!$temp_dir) { $temp_dir = '*'; } if (!defined('GETID3_TEMP_DIR')) { define('GETID3_TEMP_DIR', $temp_dir); } unset($open_basedir, $temp_dir); class getID3 { public $encoding = 'UTF-8'; public $encoding_id3v1 = 'ISO-8859-1'; public $encoding_id3v1_autodetect = false; public $option_tag_id3v1 = true; public $option_tag_id3v2 = true; public $option_tag_lyrics3 = true; public $option_tag_apetag = true; public $option_tags_process = true; public $option_tags_html = true; public $option_extra_info = true; public $option_save_attachments = true; public $option_md5_data = false; public $option_md5_data_source = false; public $option_sha1_data = false; public $option_max_2gb_check; public $option_fread_buffer_size = 32768; public $options_archive_rar_use_php_rar_extension = true; public $options_archive_gzip_parse_contents = false; public $options_audio_midi_scanwholefile = true; public $options_audio_mp3_allow_bruteforce = false; public $options_audio_mp3_mp3_valid_check_frames = 50; public $options_audio_wavpack_quick_parsing = false; public $options_audiovideo_flv_max_frames = 100000; public $options_audiovideo_matroska_hide_clusters = true; public $options_audiovideo_matroska_parse_whole_file = false; public $options_audiovideo_quicktime_ReturnAtomData = false; public $options_audiovideo_quicktime_ParseAllPossibleAtoms = false; public $options_audiovideo_swf_ReturnAllTagData = false; public $options_graphic_bmp_ExtractPalette = false; public $options_graphic_bmp_ExtractData = false; public $options_graphic_png_max_data_bytes = 10000000; public $options_misc_pdf_returnXREF = false; public $options_misc_torrent_max_torrent_filesize = 1048576; public $filename; public $fp; public $info; public $tempdir = GETID3_TEMP_DIR; public $memory_limit = 0; protected $startup_error = ''; protected $startup_warning = ''; const VERSION = '1.9.21-202109171300'; const FREAD_BUFFER_SIZE = 32768; const ATTACHMENTS_NONE = false; const ATTACHMENTS_INLINE = true; public function __construct() { $required_php_version = '5.3.0'; if (version_compare(PHP_VERSION, $required_php_version, '<')) { $this->startup_error .= 'getID3() requires PHP v'.$required_php_version.' or higher - you are running v'.PHP_VERSION."\n"; return; } $memoryLimit = ini_get('memory_limit'); if (preg_match('#([0-9]+) ?M#i', $memoryLimit, $matches)) { $memoryLimit = $matches[1] * 1048576; } elseif (preg_match('#([0-9]+) ?G#i', $memoryLimit, $matches)) { $memoryLimit = $matches[1] * 1073741824; } $this->memory_limit = $memoryLimit; if ($this->memory_limit <= 0) { } elseif ($this->memory_limit <= 4194304) { $this->startup_error .= 'PHP has less than 4MB available memory and will very likely run out. Increase memory_limit in php.ini'."\n"; } elseif ($this->memory_limit <= 12582912) { $this->startup_warning .= 'PHP has less than 12MB available memory and might run out if all modules are loaded. Increase memory_limit in php.ini'."\n"; } if (preg_match('#(1|ON)#i', ini_get('safe_mode'))) { $this->warning('WARNING: Safe mode is on, shorten support disabled, md5data/sha1data for ogg vorbis disabled, ogg vorbos/flac tag writing disabled.'); } if (($mbstring_func_overload = (int) ini_get('mbstring.func_overload')) && ($mbstring_func_overload & 0x02)) { $this->startup_error .= 'WARNING: php.ini contains "mbstring.func_overload = '.ini_get('mbstring.func_overload').'", getID3 cannot run with this setting (bitmask 2 (string functions) cannot be set). Recommended to disable entirely.'."\n"; } if (version_compare(PHP_VERSION, '7.4.0', '<')) { if (function_exists('get_magic_quotes_runtime')) { if (get_magic_quotes_runtime()) { $this->startup_error .= 'magic_quotes_runtime must be disabled before running getID3(). Surround getid3 block by set_magic_quotes_runtime(0) and set_magic_quotes_runtime(1).'."\n"; } } if (function_exists('get_magic_quotes_gpc')) { if (get_magic_quotes_gpc()) { $this->startup_error .= 'magic_quotes_gpc must be disabled before running getID3(). Surround getid3 block by set_magic_quotes_gpc(0) and set_magic_quotes_gpc(1).'."\n"; } } } if (!include_once(GETID3_INCLUDEPATH.'getid3.lib.php')) { $this->startup_error .= 'getid3.lib.php is missing or corrupt'."\n"; } if ($this->option_max_2gb_check === null) { $this->option_max_2gb_check = (PHP_INT_MAX <= 2147483647); } if (GETID3_OS_ISWINDOWS && !defined('GETID3_HELPERAPPSDIR')) { $helperappsdir = GETID3_INCLUDEPATH.'..'.DIRECTORY_SEPARATOR.'helperapps'; if (!is_dir($helperappsdir)) { $this->startup_warning .= '"'.$helperappsdir.'" cannot be defined as GETID3_HELPERAPPSDIR because it does not exist'."\n"; } elseif (strpos(realpath($helperappsdir), ' ') !== false) { $DirPieces = explode(DIRECTORY_SEPARATOR, realpath($helperappsdir)); $path_so_far = array(); foreach ($DirPieces as $key => $value) { if (strpos($value, ' ') !== false) { if (!empty($path_so_far)) { $commandline = 'dir /x '.escapeshellarg(implode(DIRECTORY_SEPARATOR, $path_so_far)); $dir_listing = `$commandline`; $lines = explode("\n", $dir_listing); foreach ($lines as $line) { $line = trim($line); if (preg_match('#^([0-9/]{10}) +([0-9:]{4,5}( [AP]M)?) +(<DIR>|[0-9,]+) +([^ ]{0,11}) +(.+)$#', $line, $matches)) { list($dummy, $date, $time, $ampm, $filesize, $shortname, $filename) = $matches; if ((strtoupper($filesize) == '<DIR>') && (strtolower($filename) == strtolower($value))) { $value = $shortname; } } } } else { $this->startup_warning .= 'GETID3_HELPERAPPSDIR must not have any spaces in it - use 8dot3 naming convention if neccesary. You can run "dir /x" from the commandline to see the correct 8.3-style names.'."\n"; } } $path_so_far[] = $value; } $helperappsdir = implode(DIRECTORY_SEPARATOR, $path_so_far); } define('GETID3_HELPERAPPSDIR', $helperappsdir.DIRECTORY_SEPARATOR); } if (!empty($this->startup_error)) { echo $this->startup_error; throw new getid3_exception($this->startup_error); } } public function version() { return self::VERSION; } public function fread_buffer_size() { return $this->option_fread_buffer_size; } public function setOption($optArray) { if (!is_array($optArray) || empty($optArray)) { return false; } foreach ($optArray as $opt => $val) { if (isset($this->$opt) === false) { continue; } $this->$opt = $val; } return true; } public function openfile($filename, $filesize=null, $fp=null) { try { if (!empty($this->startup_error)) { throw new getid3_exception($this->startup_error); } if (!empty($this->startup_warning)) { foreach (explode("\n", $this->startup_warning) as $startup_warning) { $this->warning($startup_warning); } } $this->filename = $filename; $this->info = array(); $this->info['GETID3_VERSION'] = $this->version(); $this->info['php_memory_limit'] = (($this->memory_limit > 0) ? $this->memory_limit : false); if (preg_match('#^(ht|f)tp://#', $filename)) { throw new getid3_exception('Remote files are not supported - please copy the file locally first'); } $filename = str_replace('/', DIRECTORY_SEPARATOR, $filename); if (($fp != null) && ((get_resource_type($fp) == 'file') || (get_resource_type($fp) == 'stream'))) { $this->fp = $fp; } elseif ((is_readable($filename) || file_exists($filename)) && is_file($filename) && ($this->fp = fopen($filename, 'rb'))) { } else { $errormessagelist = array(); if (!is_readable($filename)) { $errormessagelist[] = '!is_readable'; } if (!is_file($filename)) { $errormessagelist[] = '!is_file'; } if (!file_exists($filename)) { $errormessagelist[] = '!file_exists'; } if (empty($errormessagelist)) { $errormessagelist[] = 'fopen failed'; } throw new getid3_exception('Could not open "'.$filename.'" ('.implode('; ', $errormessagelist).')'); } $this->info['filesize'] = (!is_null($filesize) ? $filesize : filesize($filename)); $filename = str_replace('\\', '/', $filename); $this->info['filepath'] = str_replace('\\', '/', realpath(dirname($filename))); $this->info['filename'] = getid3_lib::mb_basename($filename); $this->info['filenamepath'] = $this->info['filepath'].'/'.$this->info['filename']; $this->info['avdataoffset'] = 0; $this->info['avdataend'] = $this->info['filesize']; $this->info['fileformat'] = ''; $this->info['audio']['dataformat'] = ''; $this->info['video']['dataformat'] = ''; $this->info['tags'] = array(); $this->info['error'] = array(); $this->info['warning'] = array(); $this->info['comments'] = array(); $this->info['encoding'] = $this->encoding; if ($this->option_max_2gb_check) { $fseek = fseek($this->fp, 0, SEEK_END); if (($fseek < 0) || (($this->info['filesize'] != 0) && (ftell($this->fp) == 0)) || ($this->info['filesize'] < 0) || (ftell($this->fp) < 0)) { $real_filesize = getid3_lib::getFileSizeSyscall($this->info['filenamepath']); if ($real_filesize === false) { unset($this->info['filesize']); fclose($this->fp); throw new getid3_exception('Unable to determine actual filesize. File is most likely larger than '.round(PHP_INT_MAX / 1073741824).'GB and is not supported by PHP.'); } elseif (getid3_lib::intValueSupported($real_filesize)) { unset($this->info['filesize']); fclose($this->fp); throw new getid3_exception('PHP seems to think the file is larger than '.round(PHP_INT_MAX / 1073741824).'GB, but filesystem reports it as '.number_format($real_filesize / 1073741824, 3).'GB, please report to info@getid3.org'); } $this->info['filesize'] = $real_filesize; $this->warning('File is larger than '.round(PHP_INT_MAX / 1073741824).'GB (filesystem reports it as '.number_format($real_filesize / 1073741824, 3).'GB) and is not properly supported by PHP.'); } } return true; } catch (Exception $e) { $this->error($e->getMessage()); } return false; } public function analyze($filename, $filesize=null, $original_filename='', $fp=null) { try { if (!$this->openfile($filename, $filesize, $fp)) { return $this->info; } foreach (array('id3v2'=>'id3v2', 'id3v1'=>'id3v1', 'apetag'=>'ape', 'lyrics3'=>'lyrics3') as $tag_name => $tag_key) { $option_tag = 'option_tag_'.$tag_name; if ($this->$option_tag) { $this->include_module('tag.'.$tag_name); try { $tag_class = 'getid3_'.$tag_name; $tag = new $tag_class($this); $tag->Analyze(); } catch (getid3_exception $e) { throw $e; } } } if (isset($this->info['id3v2']['tag_offset_start'])) { $this->info['avdataoffset'] = max($this->info['avdataoffset'], $this->info['id3v2']['tag_offset_end']); } foreach (array('id3v1'=>'id3v1', 'apetag'=>'ape', 'lyrics3'=>'lyrics3') as $tag_name => $tag_key) { if (isset($this->info[$tag_key]['tag_offset_start'])) { $this->info['avdataend'] = min($this->info['avdataend'], $this->info[$tag_key]['tag_offset_start']); } } if (!$this->option_tag_id3v2) { fseek($this->fp, 0); $header = fread($this->fp, 10); if ((substr($header, 0, 3) == 'ID3') && (strlen($header) == 10)) { $this->info['id3v2']['header'] = true; $this->info['id3v2']['majorversion'] = ord($header[3]); $this->info['id3v2']['minorversion'] = ord($header[4]); $this->info['avdataoffset'] += getid3_lib::BigEndian2Int(substr($header, 6, 4), 1) + 10; } } fseek($this->fp, $this->info['avdataoffset']); $formattest = fread($this->fp, 32774); $determined_format = $this->GetFileFormat($formattest, ($original_filename ? $original_filename : $filename)); if (!$determined_format) { fclose($this->fp); return $this->error('unable to determine file format'); } if (isset($determined_format['fail_id3']) && (in_array('id3v1', $this->info['tags']) || in_array('id3v2', $this->info['tags']))) { if ($determined_format['fail_id3'] === 'ERROR') { fclose($this->fp); return $this->error('ID3 tags not allowed on this file type.'); } elseif ($determined_format['fail_id3'] === 'WARNING') { $this->warning('ID3 tags not allowed on this file type.'); } } if (isset($determined_format['fail_ape']) && in_array('ape', $this->info['tags'])) { if ($determined_format['fail_ape'] === 'ERROR') { fclose($this->fp); return $this->error('APE tags not allowed on this file type.'); } elseif ($determined_format['fail_ape'] === 'WARNING') { $this->warning('APE tags not allowed on this file type.'); } } $this->info['mime_type'] = $determined_format['mime_type']; if (!file_exists(GETID3_INCLUDEPATH.$determined_format['include'])) { fclose($this->fp); return $this->error('Format not supported, module "'.$determined_format['include'].'" was removed.'); } if (!empty($determined_format['iconv_req']) && !function_exists('mb_convert_encoding') && !function_exists('iconv') && !in_array($this->encoding, array('ISO-8859-1', 'UTF-8', 'UTF-16LE', 'UTF-16BE', 'UTF-16'))) { $errormessage = 'mb_convert_encoding() or iconv() support is required for this module ('.$determined_format['include'].') for encodings other than ISO-8859-1, UTF-8, UTF-16LE, UTF16-BE, UTF-16. '; if (GETID3_OS_ISWINDOWS) { $errormessage .= 'PHP does not have mb_convert_encoding() or iconv() support. Please enable php_mbstring.dll / php_iconv.dll in php.ini, and copy php_mbstring.dll / iconv.dll from c:/php/dlls to c:/windows/system32'; } else { $errormessage .= 'PHP is not compiled with mb_convert_encoding() or iconv() support. Please recompile with the --enable-mbstring / --with-iconv switch'; } return $this->error($errormessage); } include_once(GETID3_INCLUDEPATH.$determined_format['include']); $class_name = 'getid3_'.$determined_format['module']; if (!class_exists($class_name)) { return $this->error('Format not supported, module "'.$determined_format['include'].'" is corrupt.'); } $class = new $class_name($this); foreach (get_object_vars($this) as $getid3_object_vars_key => $getid3_object_vars_value) { if (preg_match('#^options_([^_]+)_([^_]+)_(.+)$#i', $getid3_object_vars_key, $matches)) { list($dummy, $GOVgroup, $GOVmodule, $GOVsetting) = $matches; $GOVgroup = (($GOVgroup == 'audiovideo') ? 'audio-video' : $GOVgroup); if (($GOVgroup == $determined_format['group']) && ($GOVmodule == $determined_format['module'])) { $class->$GOVsetting = $getid3_object_vars_value; } } } $class->Analyze(); unset($class); fclose($this->fp); if ($this->option_tags_process) { $this->HandleAllTags(); } if ($this->option_extra_info) { $this->ChannelsBitratePlaytimeCalculations(); $this->CalculateCompressionRatioVideo(); $this->CalculateCompressionRatioAudio(); $this->CalculateReplayGain(); $this->ProcessAudioStreams(); } if ($this->option_md5_data) { if (!$this->option_md5_data_source || empty($this->info['md5_data_source'])) { $this->getHashdata('md5'); } } if ($this->option_sha1_data) { $this->getHashdata('sha1'); } $this->CleanUp(); } catch (Exception $e) { $this->error('Caught exception: '.$e->getMessage()); } return $this->info; } public function error($message) { $this->CleanUp(); if (!isset($this->info['error'])) { $this->info['error'] = array(); } $this->info['error'][] = $message; return $this->info; } public function warning($message) { $this->info['warning'][] = $message; return true; } private function CleanUp() { $AVpossibleEmptyKeys = array('dataformat', 'bits_per_sample', 'encoder_options', 'streams', 'bitrate'); foreach ($AVpossibleEmptyKeys as $dummy => $key) { if (empty($this->info['audio'][$key]) && isset($this->info['audio'][$key])) { unset($this->info['audio'][$key]); } if (empty($this->info['video'][$key]) && isset($this->info['video'][$key])) { unset($this->info['video'][$key]); } } if (!empty($this->info)) { foreach ($this->info as $key => $value) { if (empty($this->info[$key]) && ($this->info[$key] !== 0) && ($this->info[$key] !== '0')) { unset($this->info[$key]); } } } if (empty($this->info['fileformat'])) { if (isset($this->info['avdataoffset'])) { unset($this->info['avdataoffset']); } if (isset($this->info['avdataend'])) { unset($this->info['avdataend']); } } if (!empty($this->info['error'])) { $this->info['error'] = array_values(array_unique($this->info['error'])); } if (!empty($this->info['warning'])) { $this->info['warning'] = array_values(array_unique($this->info['warning'])); } unset($this->info['php_memory_limit']); return true; } public function GetFileFormatArray() { static $format_info = array(); if (empty($format_info)) { $format_info = array( 'ac3' => array( 'pattern' => '^\\x0B\\x77', 'group' => 'audio', 'module' => 'ac3', 'mime_type' => 'audio/ac3', ), 'adif' => array( 'pattern' => '^ADIF', 'group' => 'audio', 'module' => 'aac', 'mime_type' => 'audio/aac', 'fail_ape' => 'WARNING', ), 'adts' => array( 'pattern' => '^\\xFF[\\xF0-\\xF1\\xF8-\\xF9]', 'group' => 'audio', 'module' => 'aac', 'mime_type' => 'audio/aac', 'fail_ape' => 'WARNING', ), 'au' => array( 'pattern' => '^\\.snd', 'group' => 'audio', 'module' => 'au', 'mime_type' => 'audio/basic', ), 'amr' => array( 'pattern' => '^\\x23\\x21AMR\\x0A', 'group' => 'audio', 'module' => 'amr', 'mime_type' => 'audio/amr', ), 'avr' => array( 'pattern' => '^2BIT', 'group' => 'audio', 'module' => 'avr', 'mime_type' => 'application/octet-stream', ), 'bonk' => array( 'pattern' => '^\\x00(BONK|INFO|META| ID3)', 'group' => 'audio', 'module' => 'bonk', 'mime_type' => 'audio/xmms-bonk', ), 'dsf' => array( 'pattern' => '^DSD ', 'group' => 'audio', 'module' => 'dsf', 'mime_type' => 'audio/dsd', ), 'dss' => array( 'pattern' => '^[\\x02-\\x08]ds[s2]', 'group' => 'audio', 'module' => 'dss', 'mime_type' => 'application/octet-stream', ), 'dsdiff' => array( 'pattern' => '^FRM8', 'group' => 'audio', 'module' => 'dsdiff', 'mime_type' => 'audio/dsd', ), 'dts' => array( 'pattern' => '^\\x7F\\xFE\\x80\\x01', 'group' => 'audio', 'module' => 'dts', 'mime_type' => 'audio/dts', ), 'flac' => array( 'pattern' => '^fLaC', 'group' => 'audio', 'module' => 'flac', 'mime_type' => 'audio/flac', ), 'la' => array( 'pattern' => '^LA0[2-4]', 'group' => 'audio', 'module' => 'la', 'mime_type' => 'application/octet-stream', ), 'lpac' => array( 'pattern' => '^LPAC', 'group' => 'audio', 'module' => 'lpac', 'mime_type' => 'application/octet-stream', ), 'midi' => array( 'pattern' => '^MThd', 'group' => 'audio', 'module' => 'midi', 'mime_type' => 'audio/midi', ), 'mac' => array( 'pattern' => '^MAC ', 'group' => 'audio', 'module' => 'monkey', 'mime_type' => 'audio/x-monkeys-audio', ), 'it' => array( 'pattern' => '^IMPM', 'group' => 'audio', 'module' => 'mod', 'mime_type' => 'audio/it', ), 'xm' => array( 'pattern' => '^Extended Module', 'group' => 'audio', 'module' => 'mod', 'mime_type' => 'audio/xm', ), 's3m' => array( 'pattern' => '^.{44}SCRM', 'group' => 'audio', 'module' => 'mod', 'mime_type' => 'audio/s3m', ), 'mpc' => array( 'pattern' => '^(MPCK|MP\\+|[\\x00\\x01\\x10\\x11\\x40\\x41\\x50\\x51\\x80\\x81\\x90\\x91\\xC0\\xC1\\xD0\\xD1][\\x20-\\x37][\\x00\\x20\\x40\\x60\\x80\\xA0\\xC0\\xE0])', 'group' => 'audio', 'module' => 'mpc', 'mime_type' => 'audio/x-musepack', ), 'mp3' => array( 'pattern' => '^\\xFF[\\xE2-\\xE7\\xF2-\\xF7\\xFA-\\xFF][\\x00-\\x0B\\x10-\\x1B\\x20-\\x2B\\x30-\\x3B\\x40-\\x4B\\x50-\\x5B\\x60-\\x6B\\x70-\\x7B\\x80-\\x8B\\x90-\\x9B\\xA0-\\xAB\\xB0-\\xBB\\xC0-\\xCB\\xD0-\\xDB\\xE0-\\xEB\\xF0-\\xFB]', 'group' => 'audio', 'module' => 'mp3', 'mime_type' => 'audio/mpeg', ), 'ofr' => array( 'pattern' => '^(\\*RIFF|OFR)', 'group' => 'audio', 'module' => 'optimfrog', 'mime_type' => 'application/octet-stream', ), 'rkau' => array( 'pattern' => '^RKA', 'group' => 'audio', 'module' => 'rkau', 'mime_type' => 'application/octet-stream', ), 'shn' => array( 'pattern' => '^ajkg', 'group' => 'audio', 'module' => 'shorten', 'mime_type' => 'audio/xmms-shn', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'tak' => array( 'pattern' => '^tBaK', 'group' => 'audio', 'module' => 'tak', 'mime_type' => 'application/octet-stream', ), 'tta' => array( 'pattern' => '^TTA', 'group' => 'audio', 'module' => 'tta', 'mime_type' => 'application/octet-stream', ), 'voc' => array( 'pattern' => '^Creative Voice File', 'group' => 'audio', 'module' => 'voc', 'mime_type' => 'audio/voc', ), 'vqf' => array( 'pattern' => '^TWIN', 'group' => 'audio', 'module' => 'vqf', 'mime_type' => 'application/octet-stream', ), 'wv' => array( 'pattern' => '^wvpk', 'group' => 'audio', 'module' => 'wavpack', 'mime_type' => 'application/octet-stream', ), 'asf' => array( 'pattern' => '^\\x30\\x26\\xB2\\x75\\x8E\\x66\\xCF\\x11\\xA6\\xD9\\x00\\xAA\\x00\\x62\\xCE\\x6C', 'group' => 'audio-video', 'module' => 'asf', 'mime_type' => 'video/x-ms-asf', 'iconv_req' => false, ), 'bink' => array( 'pattern' => '^(BIK|SMK)', 'group' => 'audio-video', 'module' => 'bink', 'mime_type' => 'application/octet-stream', ), 'flv' => array( 'pattern' => '^FLV[\\x01]', 'group' => 'audio-video', 'module' => 'flv', 'mime_type' => 'video/x-flv', ), 'ivf' => array( 'pattern' => '^DKIF', 'group' => 'audio-video', 'module' => 'ivf', 'mime_type' => 'video/x-ivf', ), 'matroska' => array( 'pattern' => '^\\x1A\\x45\\xDF\\xA3', 'group' => 'audio-video', 'module' => 'matroska', 'mime_type' => 'video/x-matroska', ), 'mpeg' => array( 'pattern' => '^\\x00\\x00\\x01[\\xB3\\xBA]', 'group' => 'audio-video', 'module' => 'mpeg', 'mime_type' => 'video/mpeg', ), 'nsv' => array( 'pattern' => '^NSV[sf]', 'group' => 'audio-video', 'module' => 'nsv', 'mime_type' => 'application/octet-stream', ), 'ogg' => array( 'pattern' => '^OggS', 'group' => 'audio', 'module' => 'ogg', 'mime_type' => 'application/ogg', 'fail_id3' => 'WARNING', 'fail_ape' => 'WARNING', ), 'quicktime' => array( 'pattern' => '^.{4}(cmov|free|ftyp|mdat|moov|pnot|skip|wide)', 'group' => 'audio-video', 'module' => 'quicktime', 'mime_type' => 'video/quicktime', ), 'riff' => array( 'pattern' => '^(RIFF|SDSS|FORM)', 'group' => 'audio-video', 'module' => 'riff', 'mime_type' => 'audio/wav', 'fail_ape' => 'WARNING', ), 'real' => array( 'pattern' => '^\\.(RMF|ra)', 'group' => 'audio-video', 'module' => 'real', 'mime_type' => 'audio/x-realaudio', ), 'swf' => array( 'pattern' => '^(F|C)WS', 'group' => 'audio-video', 'module' => 'swf', 'mime_type' => 'application/x-shockwave-flash', ), 'ts' => array( 'pattern' => '^(\\x47.{187}){10,}', 'group' => 'audio-video', 'module' => 'ts', 'mime_type' => 'video/MP2T', ), 'wtv' => array( 'pattern' => '^\\xB7\\xD8\\x00\\x20\\x37\\x49\\xDA\\x11\\xA6\\x4E\\x00\\x07\\xE9\\x5E\\xAD\\x8D', 'group' => 'audio-video', 'module' => 'wtv', 'mime_type' => 'video/x-ms-wtv', ), 'bmp' => array( 'pattern' => '^BM', 'group' => 'graphic', 'module' => 'bmp', 'mime_type' => 'image/bmp', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'gif' => array( 'pattern' => '^GIF', 'group' => 'graphic', 'module' => 'gif', 'mime_type' => 'image/gif', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'jpg' => array( 'pattern' => '^\\xFF\\xD8\\xFF', 'group' => 'graphic', 'module' => 'jpg', 'mime_type' => 'image/jpeg', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'pcd' => array( 'pattern' => '^.{2048}PCD_IPI\\x00', 'group' => 'graphic', 'module' => 'pcd', 'mime_type' => 'image/x-photo-cd', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'png' => array( 'pattern' => '^\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A', 'group' => 'graphic', 'module' => 'png', 'mime_type' => 'image/png', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'svg' => array( 'pattern' => '(<!DOCTYPE svg PUBLIC |xmlns="http://www\\.w3\\.org/2000/svg")', 'group' => 'graphic', 'module' => 'svg', 'mime_type' => 'image/svg+xml', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'tiff' => array( 'pattern' => '^(II\\x2A\\x00|MM\\x00\\x2A)', 'group' => 'graphic', 'module' => 'tiff', 'mime_type' => 'image/tiff', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'efax' => array( 'pattern' => '^\\xDC\\xFE', 'group' => 'graphic', 'module' => 'efax', 'mime_type' => 'image/efax', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'iso' => array( 'pattern' => '^.{32769}CD001', 'group' => 'misc', 'module' => 'iso', 'mime_type' => 'application/octet-stream', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', 'iconv_req' => false, ), 'hpk' => array( 'pattern' => '^BPUL', 'group' => 'archive', 'module' => 'hpk', 'mime_type' => 'application/octet-stream', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'rar' => array( 'pattern' => '^Rar\\!', 'group' => 'archive', 'module' => 'rar', 'mime_type' => 'application/vnd.rar', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'szip' => array( 'pattern' => '^SZ\\x0A\\x04', 'group' => 'archive', 'module' => 'szip', 'mime_type' => 'application/octet-stream', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'tar' => array( 'pattern' => '^.{100}[0-9\\x20]{7}\\x00[0-9\\x20]{7}\\x00[0-9\\x20]{7}\\x00[0-9\\x20\\x00]{12}[0-9\\x20\\x00]{12}', 'group' => 'archive', 'module' => 'tar', 'mime_type' => 'application/x-tar', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'gz' => array( 'pattern' => '^\\x1F\\x8B\\x08', 'group' => 'archive', 'module' => 'gzip', 'mime_type' => 'application/gzip', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'zip' => array( 'pattern' => '^PK\\x03\\x04', 'group' => 'archive', 'module' => 'zip', 'mime_type' => 'application/zip', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'xz' => array( 'pattern' => '^\\xFD7zXZ\\x00', 'group' => 'archive', 'module' => 'xz', 'mime_type' => 'application/x-xz', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'par2' => array ( 'pattern' => '^PAR2\\x00PKT', 'group' => 'misc', 'module' => 'par2', 'mime_type' => 'application/octet-stream', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'pdf' => array( 'pattern' => '^\\x25PDF', 'group' => 'misc', 'module' => 'pdf', 'mime_type' => 'application/pdf', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'msoffice' => array( 'pattern' => '^\\xD0\\xCF\\x11\\xE0\\xA1\\xB1\\x1A\\xE1', 'group' => 'misc', 'module' => 'msoffice', 'mime_type' => 'application/octet-stream', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'torrent' => array( 'pattern' => '^(d8\\:announce|d7\\:comment)', 'group' => 'misc', 'module' => 'torrent', 'mime_type' => 'application/x-bittorrent', 'fail_id3' => 'ERROR', 'fail_ape' => 'ERROR', ), 'cue' => array( 'pattern' => '', 'group' => 'misc', 'module' => 'cue', 'mime_type' => 'application/octet-stream', ), ); } return $format_info; } public function GetFileFormat(&$filedata, $filename='') { foreach ($this->GetFileFormatArray() as $format_name => $info) { if (!empty($info['pattern']) && preg_match('#'.$info['pattern'].'#s', $filedata)) { $info['include'] = 'module.'.$info['group'].'.'.$info['module'].'.php'; return $info; } } if (preg_match('#\\.mp[123a]$#i', $filename)) { $GetFileFormatArray = $this->GetFileFormatArray(); $info = $GetFileFormatArray['mp3']; $info['include'] = 'module.'.$info['group'].'.'.$info['module'].'.php'; return $info; } elseif (preg_match('#\\.cue$#i', $filename) && preg_match('#FILE "[^"]+" (BINARY|MOTOROLA|AIFF|WAVE|MP3)#', $filedata)) { $GetFileFormatArray = $this->GetFileFormatArray(); $info = $GetFileFormatArray['cue']; $info['include'] = 'module.'.$info['group'].'.'.$info['module'].'.php'; return $info; } return false; } public function CharConvert(&$array, $encoding) { if ($encoding == $this->encoding) { return; } foreach ($array as $key => $value) { if (is_array($value)) { $this->CharConvert($array[$key], $encoding); } elseif (is_string($value)) { $array[$key] = trim(getid3_lib::iconv_fallback($encoding, $this->encoding, $value)); } } } public function HandleAllTags() { static $tags; if (empty($tags)) { $tags = array( 'asf' => array('asf' , 'UTF-16LE'), 'midi' => array('midi' , 'ISO-8859-1'), 'nsv' => array('nsv' , 'ISO-8859-1'), 'ogg' => array('vorbiscomment' , 'UTF-8'), 'png' => array('png' , 'UTF-8'), 'tiff' => array('tiff' , 'ISO-8859-1'), 'quicktime' => array('quicktime' , 'UTF-8'), 'real' => array('real' , 'ISO-8859-1'), 'vqf' => array('vqf' , 'ISO-8859-1'), 'zip' => array('zip' , 'ISO-8859-1'), 'riff' => array('riff' , 'ISO-8859-1'), 'lyrics3' => array('lyrics3' , 'ISO-8859-1'), 'id3v1' => array('id3v1' , $this->encoding_id3v1), 'id3v2' => array('id3v2' , 'UTF-8'), 'ape' => array('ape' , 'UTF-8'), 'cue' => array('cue' , 'ISO-8859-1'), 'matroska' => array('matroska' , 'UTF-8'), 'flac' => array('vorbiscomment' , 'UTF-8'), 'divxtag' => array('divx' , 'ISO-8859-1'), 'iptc' => array('iptc' , 'ISO-8859-1'), 'dsdiff' => array('dsdiff' , 'ISO-8859-1'), ); } foreach ($tags as $comment_name => $tagname_encoding_array) { list($tag_name, $encoding) = $tagname_encoding_array; if (isset($this->info[$comment_name]) && !isset($this->info[$comment_name]['encoding'])) { $this->info[$comment_name]['encoding'] = $encoding; } if (!empty($this->info[$comment_name]['comments'])) { foreach ($this->info[$comment_name]['comments'] as $tag_key => $valuearray) { foreach ($valuearray as $key => $value) { if (is_string($value)) { $value = trim($value, " \r\n\t"); } if (isset($value) && $value !== "") { if (!is_numeric($key)) { $this->info['tags'][trim($tag_name)][trim($tag_key)][$key] = $value; } else { $this->info['tags'][trim($tag_name)][trim($tag_key)][] = $value; } } } if ($tag_key == 'picture') { unset($this->info[$comment_name]['comments'][$tag_key]); } } if (!isset($this->info['tags'][$tag_name])) { continue; } $this->CharConvert($this->info['tags'][$tag_name], $this->info[$comment_name]['encoding']); if ($this->option_tags_html) { foreach ($this->info['tags'][$tag_name] as $tag_key => $valuearray) { if ($tag_key == 'picture') { continue; } $this->info['tags_html'][$tag_name][$tag_key] = getid3_lib::recursiveMultiByteCharString2HTML($valuearray, $this->info[$comment_name]['encoding']); } } } } if (!empty($this->info['tags'])) { $unset_keys = array('tags', 'tags_html'); foreach ($this->info['tags'] as $tagtype => $tagarray) { foreach ($tagarray as $tagname => $tagdata) { if ($tagname == 'picture') { foreach ($tagdata as $key => $tagarray) { $this->info['comments']['picture'][] = $tagarray; if (isset($tagarray['data']) && isset($tagarray['image_mime'])) { if (isset($this->info['tags'][$tagtype][$tagname][$key])) { unset($this->info['tags'][$tagtype][$tagname][$key]); } if (isset($this->info['tags_html'][$tagtype][$tagname][$key])) { unset($this->info['tags_html'][$tagtype][$tagname][$key]); } } } } } foreach ($unset_keys as $unset_key) { if (empty($this->info[$unset_key][$tagtype]['picture'])) { unset($this->info[$unset_key][$tagtype]['picture']); } if (empty($this->info[$unset_key][$tagtype])) { unset($this->info[$unset_key][$tagtype]); } if (empty($this->info[$unset_key])) { unset($this->info[$unset_key]); } } if (isset($this->info[$tagtype]['comments']['picture'])) { unset($this->info[$tagtype]['comments']['picture']); } if (empty($this->info[$tagtype]['comments'])) { unset($this->info[$tagtype]['comments']); } if (empty($this->info[$tagtype])) { unset($this->info[$tagtype]); } } } return true; } public function CopyTagsToComments(&$ThisFileInfo) { return getid3_lib::CopyTagsToComments($ThisFileInfo, $this->option_tags_html); } public function getHashdata($algorithm) { switch ($algorithm) { case 'md5': case 'sha1': break; default: return $this->error('bad algorithm "'.$algorithm.'" in getHashdata()'); } if (!empty($this->info['fileformat']) && !empty($this->info['dataformat']) && ($this->info['fileformat'] == 'ogg') && ($this->info['audio']['dataformat'] == 'vorbis')) { if (preg_match('#(1|ON)#i', ini_get('safe_mode'))) { $this->warning('Failed making system call to vorbiscomment.exe - '.$algorithm.'_data is incorrect - error returned: PHP running in Safe Mode (backtick operator not available)'); $this->info[$algorithm.'_data'] = false; } else { $old_abort = ignore_user_abort(true); $empty = tempnam(GETID3_TEMP_DIR, 'getID3'); touch($empty); $temp = tempnam(GETID3_TEMP_DIR, 'getID3'); $file = $this->info['filenamepath']; if (GETID3_OS_ISWINDOWS) { if (file_exists(GETID3_HELPERAPPSDIR.'vorbiscomment.exe')) { $commandline = '"'.GETID3_HELPERAPPSDIR.'vorbiscomment.exe" -w -c "'.$empty.'" "'.$file.'" "'.$temp.'"'; $VorbisCommentError = `$commandline`; } else { $VorbisCommentError = 'vorbiscomment.exe not found in '.GETID3_HELPERAPPSDIR; } } else { $commandline = 'vorbiscomment -w -c '.escapeshellarg($empty).' '.escapeshellarg($file).' '.escapeshellarg($temp).' 2>&1'; $VorbisCommentError = `$commandline`; } if (!empty($VorbisCommentError)) { $this->warning('Failed making system call to vorbiscomment(.exe) - '.$algorithm.'_data will be incorrect. If vorbiscomment is unavailable, please download from http://www.vorbis.com/download.psp and put in the getID3() directory. Error returned: '.$VorbisCommentError); $this->info[$algorithm.'_data'] = false; } else { switch ($algorithm) { case 'md5': $this->info[$algorithm.'_data'] = md5_file($temp); break; case 'sha1': $this->info[$algorithm.'_data'] = sha1_file($temp); break; } } unlink($empty); unlink($temp); ignore_user_abort($old_abort); } } else { if (!empty($this->info['avdataoffset']) || (isset($this->info['avdataend']) && ($this->info['avdataend'] < $this->info['filesize']))) { $this->info[$algorithm.'_data'] = getid3_lib::hash_data($this->info['filenamepath'], $this->info['avdataoffset'], $this->info['avdataend'], $algorithm); } else { switch ($algorithm) { case 'md5': $this->info[$algorithm.'_data'] = md5_file($this->info['filenamepath']); break; case 'sha1': $this->info[$algorithm.'_data'] = sha1_file($this->info['filenamepath']); break; } } } return true; } public function ChannelsBitratePlaytimeCalculations() { if (!empty($this->info['audio']['channelmode']) || !isset($this->info['audio']['channels'])) { } elseif ($this->info['audio']['channels'] == 1) { $this->info['audio']['channelmode'] = 'mono'; } elseif ($this->info['audio']['channels'] == 2) { $this->info['audio']['channelmode'] = 'stereo'; } $CombinedBitrate = 0; $CombinedBitrate += (isset($this->info['audio']['bitrate']) ? $this->info['audio']['bitrate'] : 0); $CombinedBitrate += (isset($this->info['video']['bitrate']) ? $this->info['video']['bitrate'] : 0); if (($CombinedBitrate > 0) && empty($this->info['bitrate'])) { $this->info['bitrate'] = $CombinedBitrate; } if (isset($this->info['video']['dataformat']) && $this->info['video']['dataformat'] && (!isset($this->info['video']['bitrate']) || ($this->info['video']['bitrate'] == 0))) { if (isset($this->info['audio']['bitrate']) && ($this->info['audio']['bitrate'] > 0) && ($this->info['audio']['bitrate'] == $this->info['bitrate'])) { if (isset($this->info['playtime_seconds']) && ($this->info['playtime_seconds'] > 0)) { if (isset($this->info['avdataend']) && isset($this->info['avdataoffset'])) { $this->info['bitrate'] = round((($this->info['avdataend'] - $this->info['avdataoffset']) * 8) / $this->info['playtime_seconds']); $this->info['video']['bitrate'] = $this->info['bitrate'] - $this->info['audio']['bitrate']; } } } } if ((!isset($this->info['playtime_seconds']) || ($this->info['playtime_seconds'] <= 0)) && !empty($this->info['bitrate'])) { $this->info['playtime_seconds'] = (($this->info['avdataend'] - $this->info['avdataoffset']) * 8) / $this->info['bitrate']; } if (!isset($this->info['bitrate']) && !empty($this->info['playtime_seconds'])) { $this->info['bitrate'] = (($this->info['avdataend'] - $this->info['avdataoffset']) * 8) / $this->info['playtime_seconds']; } if (isset($this->info['bitrate']) && empty($this->info['audio']['bitrate']) && empty($this->info['video']['bitrate'])) { if (isset($this->info['audio']['dataformat']) && empty($this->info['video']['resolution_x'])) { $this->info['audio']['bitrate'] = $this->info['bitrate']; } elseif (isset($this->info['video']['resolution_x']) && empty($this->info['audio']['dataformat'])) { $this->info['video']['bitrate'] = $this->info['bitrate']; } } if (!empty($this->info['playtime_seconds']) && empty($this->info['playtime_string'])) { $this->info['playtime_string'] = getid3_lib::PlaytimeString($this->info['playtime_seconds']); } } public function CalculateCompressionRatioVideo() { if (empty($this->info['video'])) { return false; } if (empty($this->info['video']['resolution_x']) || empty($this->info['video']['resolution_y'])) { return false; } if (empty($this->info['video']['bits_per_sample'])) { return false; } switch ($this->info['video']['dataformat']) { case 'bmp': case 'gif': case 'jpeg': case 'jpg': case 'png': case 'tiff': $FrameRate = 1; $PlaytimeSeconds = 1; $BitrateCompressed = $this->info['filesize'] * 8; break; default: if (!empty($this->info['video']['frame_rate'])) { $FrameRate = $this->info['video']['frame_rate']; } else { return false; } if (!empty($this->info['playtime_seconds'])) { $PlaytimeSeconds = $this->info['playtime_seconds']; } else { return false; } if (!empty($this->info['video']['bitrate'])) { $BitrateCompressed = $this->info['video']['bitrate']; } else { return false; } break; } $BitrateUncompressed = $this->info['video']['resolution_x'] * $this->info['video']['resolution_y'] * $this->info['video']['bits_per_sample'] * $FrameRate; $this->info['video']['compression_ratio'] = $BitrateCompressed / $BitrateUncompressed; return true; } public function CalculateCompressionRatioAudio() { if (empty($this->info['audio']['bitrate']) || empty($this->info['audio']['channels']) || empty($this->info['audio']['sample_rate']) || !is_numeric($this->info['audio']['sample_rate'])) { return false; } $this->info['audio']['compression_ratio'] = $this->info['audio']['bitrate'] / ($this->info['audio']['channels'] * $this->info['audio']['sample_rate'] * (!empty($this->info['audio']['bits_per_sample']) ? $this->info['audio']['bits_per_sample'] : 16)); if (!empty($this->info['audio']['streams'])) { foreach ($this->info['audio']['streams'] as $streamnumber => $streamdata) { if (!empty($streamdata['bitrate']) && !empty($streamdata['channels']) && !empty($streamdata['sample_rate'])) { $this->info['audio']['streams'][$streamnumber]['compression_ratio'] = $streamdata['bitrate'] / ($streamdata['channels'] * $streamdata['sample_rate'] * (!empty($streamdata['bits_per_sample']) ? $streamdata['bits_per_sample'] : 16)); } } } return true; } public function CalculateReplayGain() { if (isset($this->info['replay_gain'])) { if (!isset($this->info['replay_gain']['reference_volume'])) { $this->info['replay_gain']['reference_volume'] = 89.0; } if (isset($this->info['replay_gain']['track']['adjustment'])) { $this->info['replay_gain']['track']['volume'] = $this->info['replay_gain']['reference_volume'] - $this->info['replay_gain']['track']['adjustment']; } if (isset($this->info['replay_gain']['album']['adjustment'])) { $this->info['replay_gain']['album']['volume'] = $this->info['replay_gain']['reference_volume'] - $this->info['replay_gain']['album']['adjustment']; } if (isset($this->info['replay_gain']['track']['peak'])) { $this->info['replay_gain']['track']['max_noclip_gain'] = 0 - getid3_lib::RGADamplitude2dB($this->info['replay_gain']['track']['peak']); } if (isset($this->info['replay_gain']['album']['peak'])) { $this->info['replay_gain']['album']['max_noclip_gain'] = 0 - getid3_lib::RGADamplitude2dB($this->info['replay_gain']['album']['peak']); } } return true; } public function ProcessAudioStreams() { if (!empty($this->info['audio']['bitrate']) || !empty($this->info['audio']['channels']) || !empty($this->info['audio']['sample_rate'])) { if (!isset($this->info['audio']['streams'])) { foreach ($this->info['audio'] as $key => $value) { if ($key != 'streams') { $this->info['audio']['streams'][0][$key] = $value; } } } } return true; } public function getid3_tempnam() { return tempnam($this->tempdir, 'gI3'); } public function include_module($name) { if (!file_exists(GETID3_INCLUDEPATH.'module.'.$name.'.php')) { throw new getid3_exception('Required module.'.$name.'.php is missing.'); } include_once(GETID3_INCLUDEPATH.'module.'.$name.'.php'); return true; } public static function is_writable ($filename) { $ret = is_writable($filename); if (!$ret) { $perms = fileperms($filename); $ret = ($perms & 0x0080) || ($perms & 0x0010) || ($perms & 0x0002); } return $ret; } } abstract class getid3_handler { protected $getid3; protected $data_string_flag = false; protected $data_string = ''; protected $data_string_position = 0; protected $data_string_length = 0; private $dependency_to; public function __construct(getID3 $getid3, $call_module=null) { $this->getid3 = $getid3; if ($call_module) { $this->dependency_to = str_replace('getid3_', '', $call_module); } } abstract public function Analyze(); public function AnalyzeString($string) { $this->setStringMode($string); $saved_avdataoffset = $this->getid3->info['avdataoffset']; $saved_avdataend = $this->getid3->info['avdataend']; $saved_filesize = (isset($this->getid3->info['filesize']) ? $this->getid3->info['filesize'] : null); $this->getid3->info['avdataoffset'] = 0; $this->getid3->info['avdataend'] = $this->getid3->info['filesize'] = $this->data_string_length; $this->Analyze(); $this->getid3->info['avdataoffset'] = $saved_avdataoffset; $this->getid3->info['avdataend'] = $saved_avdataend; $this->getid3->info['filesize'] = $saved_filesize; $this->data_string_flag = false; } public function setStringMode($string) { $this->data_string_flag = true; $this->data_string = $string; $this->data_string_length = strlen($string); } protected function ftell() { if ($this->data_string_flag) { return $this->data_string_position; } return ftell($this->getid3->fp); } protected function fread($bytes) { if ($this->data_string_flag) { $this->data_string_position += $bytes; return substr($this->data_string, $this->data_string_position - $bytes, $bytes); } $pos = $this->ftell() + $bytes; if (!getid3_lib::intValueSupported($pos)) { throw new getid3_exception('cannot fread('.$bytes.' from '.$this->ftell().') because beyond PHP filesystem limit', 10); } $contents = ''; do { if (($this->getid3->memory_limit > 0) && (($bytes / $this->getid3->memory_limit) > 0.99)) { throw new getid3_exception('cannot fread('.$bytes.' from '.$this->ftell().') that is more than available PHP memory ('.$this->getid3->memory_limit.')', 10); } $part = fread($this->getid3->fp, $bytes); $partLength = strlen($part); $bytes -= $partLength; $contents .= $part; } while (($bytes > 0) && ($partLength > 0)); return $contents; } protected function fseek($bytes, $whence=SEEK_SET) { if ($this->data_string_flag) { switch ($whence) { case SEEK_SET: $this->data_string_position = $bytes; break; case SEEK_CUR: $this->data_string_position += $bytes; break; case SEEK_END: $this->data_string_position = $this->data_string_length + $bytes; break; } return 0; } $pos = $bytes; if ($whence == SEEK_CUR) { $pos = $this->ftell() + $bytes; } elseif ($whence == SEEK_END) { $pos = $this->getid3->info['filesize'] + $bytes; } if (!getid3_lib::intValueSupported($pos)) { throw new getid3_exception('cannot fseek('.$pos.') because beyond PHP filesystem limit', 10); } $result = fseek($this->getid3->fp, $bytes, $whence); if ($result !== 0) { throw new getid3_exception('cannot fseek('.$pos.'). resource/stream does not appear to support seeking', 10); } return $result; } protected function fgets() { $buffer = ''; $prevchar = ''; if ($this->data_string_flag) { while (true) { $thischar = substr($this->data_string, $this->data_string_position++, 1); if (($prevchar == "\r") && ($thischar != "\n")) { $this->data_string_position--; break; } $buffer .= $thischar; if ($thischar == "\n") { break; } if ($this->data_string_position >= $this->data_string_length) { break; } $prevchar = $thischar; } } else { while (true) { $thischar = fgetc($this->getid3->fp); if (($prevchar == "\r") && ($thischar != "\n")) { fseek($this->getid3->fp, -1, SEEK_CUR); break; } $buffer .= $thischar; if ($thischar == "\n") { break; } if (feof($this->getid3->fp)) { break; } $prevchar = $thischar; } } return $buffer; } protected function feof() { if ($this->data_string_flag) { return $this->data_string_position >= $this->data_string_length; } return feof($this->getid3->fp); } final protected function isDependencyFor($module) { return $this->dependency_to == $module; } protected function error($text) { $this->getid3->info['error'][] = $text; return false; } protected function warning($text) { return $this->getid3->warning($text); } protected function notice($text) { } public function saveAttachment($name, $offset, $length, $image_mime=null) { $fp_dest = null; $dest = null; try { if ($this->getid3->option_save_attachments === getID3::ATTACHMENTS_NONE) { $attachment = null; } elseif ($this->getid3->option_save_attachments === getID3::ATTACHMENTS_INLINE) { $this->fseek($offset); $attachment = $this->fread($length); if ($attachment === false || strlen($attachment) != $length) { throw new Exception('failed to read attachment data'); } } else { $dir = rtrim(str_replace(array('/', '\\'), DIRECTORY_SEPARATOR, $this->getid3->option_save_attachments), DIRECTORY_SEPARATOR); if (!is_dir($dir) || !getID3::is_writable($dir)) { throw new Exception('supplied path ('.$dir.') does not exist, or is not writable'); } $dest = $dir.DIRECTORY_SEPARATOR.$name.($image_mime ? '.'.getid3_lib::ImageExtFromMime($image_mime) : ''); if (($fp_dest = fopen($dest, 'wb')) == false) { throw new Exception('failed to create file '.$dest); } $this->fseek($offset); $buffersize = ($this->data_string_flag ? $length : $this->getid3->fread_buffer_size()); $bytesleft = $length; while ($bytesleft > 0) { if (($buffer = $this->fread(min($buffersize, $bytesleft))) === false || ($byteswritten = fwrite($fp_dest, $buffer)) === false || ($byteswritten === 0)) { throw new Exception($buffer === false ? 'not enough data to read' : 'failed to write to destination file, may be not enough disk space'); } $bytesleft -= $byteswritten; } fclose($fp_dest); $attachment = $dest; } } catch (Exception $e) { if (isset($fp_dest) && is_resource($fp_dest)) { fclose($fp_dest); } if (isset($dest) && file_exists($dest)) { unlink($dest); } $attachment = null; $this->warning('Failed to extract attachment '.$name.': '.$e->getMessage()); } $this->fseek($offset + $length); return $attachment; } } class getid3_exception extends Exception { public $message; } 